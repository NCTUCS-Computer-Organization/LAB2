$date
	Sat May  9 19:42:57 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module TestBench $end
$scope module cpu $end
$var wire 1 ! clk_i $end
$var wire 1 " rst_i $end
$var wire 1 # zero_alu $end
$var wire 32 $ pc_plus_4 [31:0] $end
$var wire 32 % pc_out [31:0] $end
$var wire 32 & pc_in [31:0] $end
$var wire 5 ' number_WriteReg_fromMux [4:0] $end
$var wire 32 ( instruction [31:0] $end
$var wire 32 ) data_into_ALU_after_mux [31:0] $end
$var wire 32 * data_after_se [31:0] $end
$var wire 32 + data_after_left2 [31:0] $end
$var wire 32 , branch_target_addr [31:0] $end
$var wire 1 - branch $end
$var wire 1 . RegWrite $end
$var wire 1 / RegDst $end
$var wire 32 0 RT_data [31:0] $end
$var wire 32 1 RS_data [31:0] $end
$var wire 32 2 RD_data [31:0] $end
$var wire 4 3 AlU_control [3:0] $end
$var wire 1 4 ALUSrc $end
$var wire 3 5 ALUOp [2:0] $end
$scope module AC $end
$var wire 6 6 funct_i [5:0] $end
$var wire 3 7 ALUOp_i [2:0] $end
$var reg 4 8 ALUCtrl_o [3:0] $end
$upscope $end
$scope module ALU $end
$var wire 4 9 ctrl_i [3:0] $end
$var wire 32 : src2_i [31:0] $end
$var wire 32 ; src1_i [31:0] $end
$var reg 32 < result_o [31:0] $end
$var reg 1 # zero_o $end
$upscope $end
$scope module Adder1 $end
$var wire 32 = src2_i [31:0] $end
$var wire 32 > sum_o [31:0] $end
$var wire 32 ? src1_i [31:0] $end
$upscope $end
$scope module Adder2 $end
$var wire 32 @ src1_i [31:0] $end
$var wire 32 A sum_o [31:0] $end
$var wire 32 B src2_i [31:0] $end
$upscope $end
$scope module Decoder $end
$var wire 6 C instr_op_i [5:0] $end
$var reg 1 4 ALUSrc_o $end
$var reg 3 D ALU_op_o [2:0] $end
$var reg 1 - Branch_o $end
$var reg 1 / RegDst_o $end
$var reg 1 . RegWrite_o $end
$upscope $end
$scope module IM $end
$var wire 32 E pc_addr_i [31:0] $end
$var reg 32 F instr_o [31:0] $end
$var integer 32 G i [31:0] $end
$upscope $end
$scope module Mux_ALUSrc $end
$var wire 1 4 select_i $end
$var wire 32 H data1_i [31:0] $end
$var wire 32 I data0_i [31:0] $end
$var reg 32 J data_o [31:0] $end
$upscope $end
$scope module Mux_PC_Source $end
$var wire 32 K data0_i [31:0] $end
$var wire 32 L data1_i [31:0] $end
$var wire 1 M select_i $end
$var reg 32 N data_o [31:0] $end
$upscope $end
$scope module Mux_Write_Reg $end
$var wire 5 O data0_i [4:0] $end
$var wire 5 P data1_i [4:0] $end
$var wire 1 / select_i $end
$var reg 5 Q data_o [4:0] $end
$upscope $end
$scope module PC $end
$var wire 1 ! clk_i $end
$var wire 32 R pc_in_i [31:0] $end
$var wire 1 " rst_i $end
$var reg 32 S pc_out_o [31:0] $end
$upscope $end
$scope module RF $end
$var wire 5 T RDaddr_i [4:0] $end
$var wire 32 U RDdata_i [31:0] $end
$var wire 5 V RSaddr_i [4:0] $end
$var wire 32 W RSdata_o [31:0] $end
$var wire 5 X RTaddr_i [4:0] $end
$var wire 32 Y RTdata_o [31:0] $end
$var wire 1 . RegWrite_i $end
$var wire 1 ! clk_i $end
$var wire 1 " rst_i $end
$upscope $end
$scope module SE $end
$var wire 16 Z data_i [15:0] $end
$var reg 32 [ data_o [31:0] $end
$upscope $end
$scope module Shifter $end
$var wire 32 \ data_i [31:0] $end
$var wire 32 ] data_o [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx00 ]
bx \
bx [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
xM
bx L
bx K
bx J
bx I
bx H
b100000 G
bx F
bx E
bx D
bx C
bx00 B
bx A
bx @
bx ?
bx >
b100 =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
x4
bx 3
bx 2
bx 1
bx 0
x/
x.
x-
bx ,
bx00 +
bx *
bx )
bx (
bx '
bx &
bx %
bx $
x#
0"
0!
$end
#5
b100 &
b100 N
b100 R
b11 )
b11 :
b11 J
b110 3
b110 8
b110 9
0#
b0xxxxxxxxxxxxxxxx00 +
b0xxxxxxxxxxxxxxxx00 B
b0xxxxxxxxxxxxxxxx00 ]
0M
b0xxxxxxxxxxxxxxxx *
b0xxxxxxxxxxxxxxxx H
b0xxxxxxxxxxxxxxxx [
b0xxxxxxxxxxxxxxxx \
0-
1/
04
b0 5
b0 7
b0 D
1.
b11111111111111111111111111111111 2
b11111111111111111111111111111111 <
b11111111111111111111111111111111 U
b0 '
b0 Q
b0 T
b100011 Z
b100011 6
b0 C
b11 0
b11 I
b11 Y
b11 X
b10 1
b10 ;
b10 W
b10 V
b0 P
b11 O
b10000110000000000100011 (
b10000110000000000100011 F
b100 $
b100 >
b100 @
b100 K
b0 %
b0 ?
b0 E
b0 S
1!
#10
0!
1"
#15
b101 )
b101 :
b101 J
b100 2
b100 <
b100 U
b1 '
b1 Q
b1 T
b1000 &
b1000 N
b1000 R
b100000100011 Z
b101 0
b101 I
b101 Y
b101 X
b1001 1
b1001 ;
b1001 W
b1001 V
b1 P
b101 O
b1001001010000100000100011 (
b1001001010000100000100011 F
b1000 $
b1000 >
b1000 @
b1000 K
b100 %
b100 ?
b100 E
b100 S
1!
#20
0!
#25
b11111111111111111111111111111111 )
b11111111111111111111111111111111 :
b11111111111111111111111111111111 J
b101 2
b101 <
b101 U
b1011 '
b1011 Q
b1011 T
b1100 &
b1100 N
b1100 R
b101100000100011 Z
b11111111111111111111111111111111 0
b11111111111111111111111111111111 I
b11111111111111111111111111111111 Y
b0 X
b100 1
b100 ;
b100 W
b1 V
b1011 P
b0 O
b1000000101100000100011 (
b1000000101100000100011 F
b1100 $
b1100 >
b1100 @
b1100 K
b1000 %
b1000 ?
b1000 E
b1000 S
1!
#30
0!
#35
1#
b0 2
b0 <
b0 U
b0 '
b0 Q
b0 T
b10000 &
b10000 N
b10000 R
b0 Z
b0 6
b11111111111111111111111111111111 1
b11111111111111111111111111111111 ;
b11111111111111111111111111111111 W
b0 V
b0 P
b0 (
b0 F
b10000 $
b10000 >
b10000 @
b10000 K
b1100 %
b1100 ?
b1100 E
b1100 S
1!
#40
0!
#45
1#
b10100 &
b10100 N
b10100 R
b0 2
b0 <
b0 U
b0 )
b0 :
b0 J
b10100 $
b10100 >
b10100 @
b10100 K
b10000 %
b10000 ?
b10000 E
b10000 S
b0 1
b0 ;
b0 W
b0 0
b0 I
b0 Y
1!
