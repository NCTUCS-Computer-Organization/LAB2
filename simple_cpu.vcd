$date
	Sat May  9 18:02:38 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module TestBench $end
$scope module cpu $end
$var wire 1 ! Regwrite $end
$var wire 1 " clk_i $end
$var wire 1 # rst_i $end
$var wire 1 $ zero_alu $end
$var wire 32 % pc_plus_4 [31:0] $end
$var wire 32 & pc_out [31:0] $end
$var wire 32 ' pc_in [31:0] $end
$var wire 5 ( number_WriteReg_fromMux [4:0] $end
$var wire 32 ) instruction [31:0] $end
$var wire 32 * data_into_ALU_after_mux [31:0] $end
$var wire 32 + data_after_se [31:0] $end
$var wire 32 , data_after_left2 [31:0] $end
$var wire 32 - branch_target_addr [31:0] $end
$var wire 1 . branch $end
$var wire 1 / RegWrite $end
$var wire 1 0 RegDst $end
$var wire 32 1 RT_data [31:0] $end
$var wire 32 2 RS_data [31:0] $end
$var wire 32 3 RD_data [31:0] $end
$var wire 4 4 AlU_control [3:0] $end
$var wire 1 5 ALUSrc $end
$var wire 3 6 ALUOp [2:0] $end
$scope module AC $end
$var wire 6 7 funct_i [5:0] $end
$var wire 3 8 ALUOp_i [2:0] $end
$var reg 4 9 ALUCtrl_o [3:0] $end
$upscope $end
$scope module ALU $end
$var wire 4 : ctrl_i [3:0] $end
$var wire 32 ; src2_i [31:0] $end
$var wire 32 < src1_i [31:0] $end
$var reg 32 = result_o [31:0] $end
$var reg 1 $ zero_o $end
$upscope $end
$scope module Adder1 $end
$var wire 32 > src2_i [31:0] $end
$var wire 32 ? sum_o [31:0] $end
$var wire 32 @ src1_i [31:0] $end
$upscope $end
$scope module Adder2 $end
$var wire 32 A src1_i [31:0] $end
$var wire 32 B sum_o [31:0] $end
$var wire 32 C src2_i [31:0] $end
$upscope $end
$scope module Decoder $end
$var wire 6 D instr_op_i [5:0] $end
$var reg 1 5 ALUSrc_o $end
$var reg 3 E ALU_op_o [2:0] $end
$var reg 1 . Branch_o $end
$var reg 1 0 RegDst_o $end
$var reg 1 / RegWrite_o $end
$upscope $end
$scope module IM $end
$var wire 32 F pc_addr_i [31:0] $end
$var reg 32 G instr_o [31:0] $end
$var integer 32 H i [31:0] $end
$upscope $end
$scope module Mux_ALUSrc $end
$var wire 1 5 select_i $end
$var wire 32 I data1_i [31:0] $end
$var wire 32 J data0_i [31:0] $end
$var reg 32 K data_o [31:0] $end
$upscope $end
$scope module Mux_PC_Source $end
$var wire 32 L data0_i [31:0] $end
$var wire 32 M data1_i [31:0] $end
$var wire 1 N select_i $end
$var reg 32 O data_o [31:0] $end
$upscope $end
$scope module Mux_Write_Reg $end
$var wire 5 P data0_i [4:0] $end
$var wire 5 Q data1_i [4:0] $end
$var wire 1 0 select_i $end
$var reg 5 R data_o [4:0] $end
$upscope $end
$scope module PC $end
$var wire 1 " clk_i $end
$var wire 32 S pc_in_i [31:0] $end
$var wire 1 # rst_i $end
$var reg 32 T pc_out_o [31:0] $end
$upscope $end
$scope module RF $end
$var wire 5 U RDaddr_i [4:0] $end
$var wire 32 V RDdata_i [31:0] $end
$var wire 5 W RSaddr_i [4:0] $end
$var wire 32 X RSdata_o [31:0] $end
$var wire 5 Y RTaddr_i [4:0] $end
$var wire 32 Z RTdata_o [31:0] $end
$var wire 1 ! RegWrite_i $end
$var wire 1 " clk_i $end
$var wire 1 # rst_i $end
$upscope $end
$scope module SE $end
$var wire 16 [ data_i [15:0] $end
$var reg 32 \ data_o [31:0] $end
$upscope $end
$scope module Shifter $end
$var wire 32 ] data_i [31:0] $end
$var wire 32 ^ data_o [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx00 ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
xN
bx M
bx L
bx K
bx J
bx I
b100000 H
bx G
bx F
bx E
bx D
bx00 C
bx B
bx A
bx @
bx ?
b100 >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
x5
bx 4
bx 3
bx 2
bx 1
x0
x/
x.
bx -
bx00 ,
bx +
bx *
bx )
bx (
bx '
bx &
bx %
x$
0#
0"
z!
$end
#5
b100 '
b100 O
b100 S
b11 *
b11 ;
b11 K
b10 4
b10 9
b10 :
0$
b0xxxxxxxxxxxxxxxx00 ,
b0xxxxxxxxxxxxxxxx00 C
b0xxxxxxxxxxxxxxxx00 ^
0N
b0xxxxxxxxxxxxxxxx +
b0xxxxxxxxxxxxxxxx I
b0xxxxxxxxxxxxxxxx \
b0xxxxxxxxxxxxxxxx ]
0.
10
05
b0 6
b0 8
b0 E
1/
b101 3
b101 =
b101 V
b0 (
b0 R
b0 U
b100001 [
b100001 7
b0 D
b11 1
b11 J
b11 Z
b11 Y
b10 2
b10 <
b10 X
b10 W
b0 Q
b11 P
b10000110000000000100001 )
b10000110000000000100001 G
b100 %
b100 ?
b100 A
b100 L
b0 &
b0 @
b0 F
b0 T
1"
#10
0"
1#
#15
b101 *
b101 ;
b101 K
b1001 3
b1001 =
b1001 V
b1 (
b1 R
b1 U
b1000 '
b1000 O
b1000 S
b100000100001 [
b101 1
b101 J
b101 Z
b101 Y
b100 2
b100 <
b100 X
b100 W
b1 Q
b101 P
b100001010000100000100001 )
b100001010000100000100001 G
b1000 %
b1000 ?
b1000 A
b1000 L
b100 &
b100 @
b100 F
b100 T
1"
#20
0"
#25
b1000 *
b1000 ;
b1000 K
b111 3
b111 =
b111 V
b110 (
b110 R
b110 U
b1100 '
b1100 O
b1100 S
b11000000100001 [
b1000 1
b1000 J
b1000 Z
b1000 Y
b11111111111111111111111111111111 2
b11111111111111111111111111111111 <
b11111111111111111111111111111111 X
b1010 W
b110 Q
b1000 P
b1010010000011000000100001 )
b1010010000011000000100001 G
b1100 %
b1100 ?
b1100 A
b1100 L
b1000 &
b1000 @
b1000 F
b1000 T
1"
#30
0"
#35
1$
b0 *
b0 ;
b0 K
b0 3
b0 =
b0 V
b0 (
b0 R
b0 U
b10000 '
b10000 O
b10000 S
b0 [
b0 7
b0 1
b0 J
b0 Z
b0 Y
b0 2
b0 <
b0 X
b0 W
b0 Q
b0 P
b0 )
b0 G
b10000 %
b10000 ?
b10000 A
b10000 L
b1100 &
b1100 @
b1100 F
b1100 T
1"
#40
0"
#45
b10100 '
b10100 O
b10100 S
b10100 %
b10100 ?
b10100 A
b10100 L
b10000 &
b10000 @
b10000 F
b10000 T
1"
